<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FleCSI Core API: Unstructured Mesh</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="tab_a.png" rel="stylesheet" type="text/css"/>
<link href="tab_b.png" rel="stylesheet" type="text/css"/>
<link href="tab_h.png" rel="stylesheet" type="text/css"/>
<link href="tab_s.png" rel="stylesheet" type="text/css"/>
<link href="nav_f.png" rel="stylesheet" type="text/css"/>
<link href="nav_g.png" rel="stylesheet" type="text/css"/>
<link href="nav_h.png" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="flecsi.png"/></td>
  <td id="projectalign">
   <div id="projectname">FleCSI Core API<span id="projectnumber">&#160;Version: 2.2.1</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__unstructured.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Unstructured Mesh<div class="ingroups"><a class="el" href="group__topology.html">Topologies</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Configurable unstructured mesh interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured_1_1access.html">unstructured&lt; Policy &gt;::access&lt; Privileges &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology interface base.  <a href="structflecsi_1_1topo_1_1unstructured_1_1access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured__base_1_1coloring.html">unstructured_base::coloring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coloring data structure is how information is passed to the FleCSI runtime to construct one or more unstructured mesh specialization types.  <a href="structflecsi_1_1topo_1_1unstructured__base_1_1coloring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured__impl_1_1coloring__definition.html">coloring_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy for contructing colorings.  <a href="structflecsi_1_1topo_1_1unstructured__impl_1_1coloring__definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured__impl_1_1coloring__utils.html">coloring_utils&lt; MD &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structflecsi_1_1topo_1_1unstructured__impl_1_1coloring__utils.html" title="The coloring_utils interface provides utility methods for generating colorings of unstructured input ...">coloring_utils</a> interface provides utility methods for generating colorings of unstructured input meshes.  <a href="structflecsi_1_1topo_1_1unstructured__impl_1_1coloring__utils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured__impl_1_1index__color.html">index_color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information specific to a single index space and color.  <a href="structflecsi_1_1topo_1_1unstructured__impl_1_1index__color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured__impl_1_1mesh__definition.html">mesh_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example mesh definition that is not really implemented.  <a href="structflecsi_1_1topo_1_1unstructured__impl_1_1mesh__definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured.html">unstructured&lt; Policy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology type.  <a href="structflecsi_1_1topo_1_1unstructured.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1topo_1_1unstructured__specialization.html">unstructured_specialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example specialization which is not really implemented.  <a href="structflecsi_1_1topo_1_1unstructured__specialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac839ee18362f6ab89ab41d3da34b5afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gac839ee18362f6ab89ab41d3da34b5afb">build_intermediary</a> (std::size_t kind, const <a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> &amp;e2v, std::vector&lt; <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">util::gid</a> &gt; const &amp;p2m)</td></tr>
<tr class="memdesc:gac839ee18362f6ab89ab41d3da34b5afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build intermediary entities locally from entity to vertex graph.  <br /></td></tr>
<tr class="separator:gac839ee18362f6ab89ab41d3da34b5afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4f162b661bd9705b46aacb4d90c9447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gac4f162b661bd9705b46aacb4d90c9447">close_auxiliary</a> (entity_kind kind, std::size_t idx)</td></tr>
<tr class="memdesc:gac4f162b661bd9705b46aacb4d90c9447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the local auxiliary distributions with respect to off-color dependencies, i.e., assemble the local shared and ghost information.  <br /></td></tr>
<tr class="separator:gac4f162b661bd9705b46aacb4d90c9447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f96843414939798c4820859def7324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gab4f96843414939798c4820859def7324">close_primaries</a> ()</td></tr>
<tr class="memdesc:gab4f96843414939798c4820859def7324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the local primary distributions with respect to off-color dependencies, i.e., assemble the local shared and ghost information.  <br /></td></tr>
<tr class="separator:gab4f96843414939798c4820859def7324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3287aba6c89c1c9a3df6447ffb66fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#ga1c3287aba6c89c1c9a3df6447ffb66fb">close_vertices</a> ()</td></tr>
<tr class="memdesc:ga1c3287aba6c89c1c9a3df6447ffb66fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the local vertex distributions with respect to off-color dependencies, i.e., assemble the local shared and ghost information.  <br /></td></tr>
<tr class="separator:ga1c3287aba6c89c1c9a3df6447ffb66fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f0b7063918e843cf97799ee066287c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gab7f0b7063918e843cf97799ee066287c">color_auxiliary</a> (entity_kind kind)</td></tr>
<tr class="memdesc:gab7f0b7063918e843cf97799ee066287c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the auxiliary coloring induced by the primary coloring using the heuristic that each auxiliary is assigned the color of the lowest color of a primary that references it.  <br /></td></tr>
<tr class="separator:gab7f0b7063918e843cf97799ee066287c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3a2378568dad9a6361144af59b51fd3"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:gad3a2378568dad9a6361144af59b51fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gad3a2378568dad9a6361144af59b51fd3">color_primaries</a> (<a class="el" href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">util::id</a> shared, C &amp;&amp;c)</td></tr>
<tr class="memdesc:gad3a2378568dad9a6361144af59b51fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color the primary entity type using the provided coloring function.  <br /></td></tr>
<tr class="separator:gad3a2378568dad9a6361144af59b51fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa627f63c1601e5a85e47bf228d690a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gaa627f63c1601e5a85e47bf228d690a48">color_vertices</a> ()</td></tr>
<tr class="memdesc:gaa627f63c1601e5a85e47bf228d690a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the vertex coloring induced by the primary coloring using the heuristic that each vertex is assigned the color of the lowest color of a primary that references it.  <br /></td></tr>
<tr class="separator:gaa627f63c1601e5a85e47bf228d690a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa61fca3e708e5fa776b235f9f7487bfd"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gaa61fca3e708e5fa776b235f9f7487bfd">generate</a> ()</td></tr>
<tr class="memdesc:gaa61fca3e708e5fa776b235f9f7487bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the coloring object.  <br /></td></tr>
<tr class="separator:gaa61fca3e708e5fa776b235f9f7487bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700d0421c6b6a0bf5fa22ce5f7d92a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#ga700d0421c6b6a0bf5fa22ce5f7d92a84">intersect_connectivity</a> (const <a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> &amp;c2f, const <a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> &amp;f2e)</td></tr>
<tr class="memdesc:ga700d0421c6b6a0bf5fa22ce5f7d92a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build connectivity through connectivity intersection.  <br /></td></tr>
<tr class="separator:ga700d0421c6b6a0bf5fa22ce5f7d92a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeef22024e26ae0637e5f5d7ee739e30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#gaaeef22024e26ae0637e5f5d7ee739e30">migrate_primaries</a> ()</td></tr>
<tr class="memdesc:gaaeef22024e26ae0637e5f5d7ee739e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute the primary entities.  <br /></td></tr>
<tr class="separator:gaaeef22024e26ae0637e5f5d7ee739e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2c84389bc92f4660f00054a93f531f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Color &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unstructured.html#ga3b2c84389bc92f4660f00054a93f531f">request_owners</a> (const std::vector&lt; <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">util::gid</a> &gt; &amp;, <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">util::gid</a> n, const std::vector&lt; Color &gt; &amp;) const</td></tr>
<tr class="memdesc:ga3b2c84389bc92f4660f00054a93f531f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request owner information about the given entity list from the naive owners.  <br /></td></tr>
<tr class="separator:ga3b2c84389bc92f4660f00054a93f531f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ebf9c593ed9baac3fb15c6f2d6af557"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7ebf9c593ed9baac3fb15c6f2d6af557"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__unstructured.html#ga7ebf9c593ed9baac3fb15c6f2d6af557">send_field</a> (entity_kind kind, const std::vector&lt; T &gt; &amp;elems)</td></tr>
<tr class="memdesc:ga7ebf9c593ed9baac3fb15c6f2d6af557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute a field based on the existing <code>kind</code> repartition.  <br /></td></tr>
<tr class="separator:ga7ebf9c593ed9baac3fb15c6f2d6af557"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Configurable unstructured mesh interface. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga700d0421c6b6a0bf5fa22ce5f7d92a84" name="ga700d0421c6b6a0bf5fa22ce5f7d92a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga700d0421c6b6a0bf5fa22ce5f7d92a84">&#9670;&#160;</a></span>intersect_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> intersect_connectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> &amp;&#160;</td>
          <td class="paramname"><em>c2f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> &amp;&#160;</td>
          <td class="paramname"><em>f2e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build connectivity through connectivity intersection. </p>
<p>Given X-to-Y and Y-to-Z connectivities, build X-to-Z connectivity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c2f</td><td>X-to-Y connectivity </td></tr>
    <tr><td class="paramname">f2e</td><td>Y-to-Z connectivity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X-to-Z connectivity (c2e) </dd></dl>

</div>
</div>
<a id="gad3a2378568dad9a6361144af59b51fd3" name="gad3a2378568dad9a6361144af59b51fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3a2378568dad9a6361144af59b51fd3">&#9670;&#160;</a></span>color_primaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> color_primaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">util::id</a>&#160;</td>
          <td class="paramname"><em>shared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color the primary entity type using the provided coloring function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shared</td><td>maximum number of shared vertices to disregard </td></tr>
    <tr><td class="paramname">c</td><td>coloring function object with the signature of <a class="el" href="group__utils.html#ga3143790d16e2075e12b625290311e67d" title="Generate a coloring of the given naive graph partition into colors colors.">flecsi::util::parmetis::color</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method first marshalls the naive partition information on the root process and sends the respective data to each initially-owning process. The current implementation is designed to avoid having many processes hit the file system at once. This may not be optimal on all parallel file systems. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method will fail on certain non-convex mesh entities. In particular, if a non-convex cell abuts a cell that is inscribed in the convex hull of the non-convex entity, it is possible that the non-convex entity will share <em>shared</em> vertices with an entity that abuts the convex hull without actually being connected. Other similar cases of this nature are also possible. </dd></dl>

</div>
</div>
<a id="gaaeef22024e26ae0637e5f5d7ee739e30" name="gaaeef22024e26ae0637e5f5d7ee739e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeef22024e26ae0637e5f5d7ee739e30">&#9670;&#160;</a></span>migrate_primaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void migrate_primaries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redistribute the primary entities. </p>
<p>This method moves the primary entities to their owning colors. </p>

</div>
</div>
<a id="ga3b2c84389bc92f4660f00054a93f531f" name="ga3b2c84389bc92f4660f00054a93f531f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2c84389bc92f4660f00054a93f531f">&#9670;&#160;</a></span>request_owners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Color &gt; request_owners </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">util::gid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">util::gid</a>&#160;</td>
          <td class="paramname"><em>ne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Color &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_cos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request owner information about the given entity list from the naive owners. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The global ids of the desired entities. </td></tr>
    <tr><td class="paramname">ne</td><td>The global number of entities. </td></tr>
    <tr><td class="paramname">idx_cos</td><td>The naive coloring of the entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the owning process for each entity </dd></dl>

</div>
</div>
<a id="gab4f96843414939798c4820859def7324" name="gab4f96843414939798c4820859def7324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f96843414939798c4820859def7324">&#9670;&#160;</a></span>close_primaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_primaries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the local primary distributions with respect to off-color dependencies, i.e., assemble the local shared and ghost information. </p>

</div>
</div>
<a id="gaa627f63c1601e5a85e47bf228d690a48" name="gaa627f63c1601e5a85e47bf228d690a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa627f63c1601e5a85e47bf228d690a48">&#9670;&#160;</a></span>color_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void color_vertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the vertex coloring induced by the primary coloring using the heuristic that each vertex is assigned the color of the lowest color of a primary that references it. </p>

</div>
</div>
<a id="ga1c3287aba6c89c1c9a3df6447ffb66fb" name="ga1c3287aba6c89c1c9a3df6447ffb66fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3287aba6c89c1c9a3df6447ffb66fb">&#9670;&#160;</a></span>close_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_vertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the local vertex distributions with respect to off-color dependencies, i.e., assemble the local shared and ghost information. </p>

</div>
</div>
<a id="gab7f0b7063918e843cf97799ee066287c" name="gab7f0b7063918e843cf97799ee066287c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7f0b7063918e843cf97799ee066287c">&#9670;&#160;</a></span>color_auxiliary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void color_auxiliary </td>
          <td>(</td>
          <td class="paramtype">entity_kind&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the auxiliary coloring induced by the primary coloring using the heuristic that each auxiliary is assigned the color of the lowest color of a primary that references it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The mesh definition entity kind of the auxiliary to color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4f162b661bd9705b46aacb4d90c9447" name="gac4f162b661bd9705b46aacb4d90c9447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4f162b661bd9705b46aacb4d90c9447">&#9670;&#160;</a></span>close_auxiliary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_auxiliary </td>
          <td>(</td>
          <td class="paramtype">entity_kind&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the local auxiliary distributions with respect to off-color dependencies, i.e., assemble the local shared and ghost information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The mesh definition entity kind of the auxiliary to close. </td></tr>
    <tr><td class="paramname">idx</td><td>The entity index space of the auxiliary to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac839ee18362f6ab89ab41d3da34b5afb" name="gac839ee18362f6ab89ab41d3da34b5afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac839ee18362f6ab89ab41d3da34b5afb">&#9670;&#160;</a></span>build_intermediary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void build_intermediary </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1crs.html">util::crs</a> &amp;&#160;</td>
          <td class="paramname"><em>e2v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">util::gid</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p2m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build intermediary entities locally from entity to vertex graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The mesh definition entity kind. </td></tr>
    <tr><td class="paramname">e2v</td><td>entity to vertex graph. </td></tr>
    <tr><td class="paramname">p2m</td><td>primary (global) ID for each row of <em>e2v</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa61fca3e708e5fa776b235f9f7487bfd" name="gaa61fca3e708e5fa776b235f9f7487bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa61fca3e708e5fa776b235f9f7487bfd">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; generate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the coloring object. </p>
<p>Note that this method has side effects: it gathers global peer information for the superset of communication pairs over the collection of index spaces in the coloring, and it computes the connectivity allocation sizes for the connectivities specified in the <a class="el" href="structflecsi_1_1topo_1_1unstructured__impl_1_1coloring__definition.html" title="Strategy for contructing colorings.">coloring_definition</a>. </p>

</div>
</div>
<a id="ga7ebf9c593ed9baac3fb15c6f2d6af557" name="ga7ebf9c593ed9baac3fb15c6f2d6af557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ebf9c593ed9baac3fb15c6f2d6af557">&#9670;&#160;</a></span>send_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; send_field </td>
          <td>(</td>
          <td class="paramtype">entity_kind&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distribute a field based on the existing <code>kind</code> repartition. </p>
<p>Only primaries and vertices entity_kind are supported. The input, <code>elems</code>, must be empty everywhere except on rank 0. This function returns a vector of vectors of the field distributed in a fashion similar to ParMETIS. Each vector correspond to the colors of the process, in order. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
