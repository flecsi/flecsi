<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FleCSI Core API: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="tab_a.png" rel="stylesheet" type="text/css"/>
<link href="tab_b.png" rel="stylesheet" type="text/css"/>
<link href="tab_h.png" rel="stylesheet" type="text/css"/>
<link href="tab_s.png" rel="stylesheet" type="text/css"/>
<link href="nav_f.png" rel="stylesheet" type="text/css"/>
<link href="nav_g.png" rel="stylesheet" type="text/css"/>
<link href="nav_h.png" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="flecsi.png"/></td>
  <td id="projectalign">
   <div id="projectname">FleCSI Core API<span id="projectnumber">&#160;Version: 2.2.1</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__utils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utilities</div></div>
</div><!--header-->
<div class="contents">

<p>Non-domain-specific infrastructure.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__annotation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__annotation.html">Profiling</a></td></tr>
<tr class="memdesc:group__annotation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Markers for categorizing performance measurements. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html">Point</a></td></tr>
<tr class="memdesc:group__point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial representation of a point based on <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__graphviz"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graphviz.html">Graphviz Support</a></td></tr>
<tr class="memdesc:group__graphviz"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code>libcgraph</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mpi-utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpi-utils.html">MPI</a></td></tr>
<tr class="memdesc:group__mpi-utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">These require MPI tasks, not the MPI backend. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__serial"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html">Serialization</a></td></tr>
<tr class="memdesc:group__serial"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization without default constructibility. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__unit"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unit.html">Unit Testing</a></td></tr>
<tr class="memdesc:group__unit"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit test framework much like Google Test but with task support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ranges.html">Ranges</a></td></tr>
<tr class="memdesc:group__ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range and iterator tools, mostly backported from the standard library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1counter.html">counter&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter with a maximum.  <a href="structflecsi_1_1util_1_1counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1crs.html">crs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient (compressed-row) storage for a sequence of sequences of integers.  <a href="structflecsi_1_1util_1_1crs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1dag.html">dag&lt; NodePolicy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic DAG type.  <a href="structflecsi_1_1util_1_1dag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1equal__map.html">equal_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition with substrings of equal size.  <a href="structflecsi_1_1util_1_1equal__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a type as itself in functional contexts.  <a href="structflecsi_1_1util_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1key__tuple.html">key_tuple&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::tuple containing the given types and indexed by the given keys.  <a href="structflecsi_1_1util_1_1key__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1map__base.html">map_base&lt; D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition of some prefix of the whole numbers into substrings.  <a href="structflecsi_1_1util_1_1map__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1offsets.html">offsets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition with substrings of arbitrary size.  <a href="structflecsi_1_1util_1_1offsets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1Symbol.html">Symbol&lt; S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy class template.  <a href="structflecsi_1_1util_1_1Symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadb0a7b5d1090ea55d936d3b15c66ca8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadb0a7b5d1090ea55d936d3b15c66ca8d">FLECSI_INLINE_TARGET</a></td></tr>
<tr class="memdesc:gadb0a7b5d1090ea55d936d3b15c66ca8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a function inline and available on a GPU.  <a href="group__utils.html#gadb0a7b5d1090ea55d936d3b15c66ca8d">More...</a><br /></td></tr>
<tr class="separator:gadb0a7b5d1090ea55d936d3b15c66ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91f6cc1b8c725b6d4d29620999d336e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab91f6cc1b8c725b6d4d29620999d336e">FLECSI_TARGET</a></td></tr>
<tr class="memdesc:gab91f6cc1b8c725b6d4d29620999d336e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a function available on a GPU.  <a href="group__utils.html#gab91f6cc1b8c725b6d4d29620999d336e">More...</a><br /></td></tr>
<tr class="separator:gab91f6cc1b8c725b6d4d29620999d336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0d633ccab8440bedc968dc221a91849f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> = unsigned short</td></tr>
<tr class="memdesc:ga0d633ccab8440bedc968dc221a91849f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for spatial dimensions and counts thereof.  <a href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">More...</a><br /></td></tr>
<tr class="separator:ga0d633ccab8440bedc968dc221a91849f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72254e85c5f54a8d398eac641258ee45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">gid</a> = FLECSI_GID_TYPE</td></tr>
<tr class="memdesc:ga72254e85c5f54a8d398eac641258ee45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global topology entity ID type.  <a href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">More...</a><br /></td></tr>
<tr class="separator:ga72254e85c5f54a8d398eac641258ee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcbd6f3f473db13e944c75433a5ba8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">id</a> = FLECSI_ID_TYPE</td></tr>
<tr class="memdesc:ga6dcbd6f3f473db13e944c75433a5ba8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local (color-specific) topology entity ID type.  <a href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">More...</a><br /></td></tr>
<tr class="separator:ga6dcbd6f3f473db13e944c75433a5ba8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga43129c21901de6eff552977dbbd5cb42"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga43129c21901de6eff552977dbbd5cb42"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga43129c21901de6eff552977dbbd5cb42">bit_width</a> (T x) noexcept</td></tr>
<tr class="memdesc:ga43129c21901de6eff552977dbbd5cb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple emulation of std::bit_width from C++20.  <a href="group__utils.html#ga43129c21901de6eff552977dbbd5cb42">More...</a><br /></td></tr>
<tr class="separator:ga43129c21901de6eff552977dbbd5cb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171881d08c3db40bdaa058ee1dd37c4d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Color &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga171881d08c3db40bdaa058ee1dd37c4d">color</a> (const <a class="el" href="structflecsi_1_1util_1_1offsets.html">util::offsets</a> &amp;dist, const <a class="el" href="structflecsi_1_1util_1_1crs.html">crs</a> &amp;graph, idx_t colors, MPI_Comm comm=MPI_COMM_WORLD)</td></tr>
<tr class="memdesc:ga171881d08c3db40bdaa058ee1dd37c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a coloring of the given naive graph partition into <em>colors</em> colors.  <a href="group__utils.html#ga171881d08c3db40bdaa058ee1dd37c4d">More...</a><br /></td></tr>
<tr class="separator:ga171881d08c3db40bdaa058ee1dd37c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38729997ae0745c4d90e7e2cafb32fa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab38729997ae0745c4d90e7e2cafb32fa">demangle</a> (const char *const name)</td></tr>
<tr class="memdesc:gab38729997ae0745c4d90e7e2cafb32fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the demangled name.  <a href="group__utils.html#gab38729997ae0745c4d90e7e2cafb32fa">More...</a><br /></td></tr>
<tr class="separator:gab38729997ae0745c4d90e7e2cafb32fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090b1ad4ee999a66e624adfb9adc65be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga090b1ad4ee999a66e624adfb9adc65be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga090b1ad4ee999a66e624adfb9adc65be">force_unique</a> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga090b1ad4ee999a66e624adfb9adc65be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a std::vector and remove duplicates.  <a href="group__utils.html#ga090b1ad4ee999a66e624adfb9adc65be">More...</a><br /></td></tr>
<tr class="separator:ga090b1ad4ee999a66e624adfb9adc65be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c20a85c5e76f886f6535b6ab3a7eb4"><td class="memTemplParams" colspan="2">template&lt;class InputIt1 , class InputIt2 &gt; </td></tr>
<tr class="memitem:ga95c20a85c5e76f886f6535b6ab3a7eb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga95c20a85c5e76f886f6535b6ab3a7eb4">intersects</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2)</td></tr>
<tr class="memdesc:ga95c20a85c5e76f886f6535b6ab3a7eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect intersections of sorted lists.  <a href="group__utils.html#ga95c20a85c5e76f886f6535b6ab3a7eb4">More...</a><br /></td></tr>
<tr class="separator:ga95c20a85c5e76f886f6535b6ab3a7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1859e483fdc35d0102a16d01fec65b28"><td class="memTemplParams" colspan="2">template&lt;typename order_iterator , typename value_iterator &gt; </td></tr>
<tr class="memitem:ga1859e483fdc35d0102a16d01fec65b28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga1859e483fdc35d0102a16d01fec65b28">reorder</a> (const order_iterator order_begin, const order_iterator order_end, const value_iterator v)</td></tr>
<tr class="memdesc:ga1859e483fdc35d0102a16d01fec65b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders an array in place.  <a href="group__utils.html#ga1859e483fdc35d0102a16d01fec65b28">More...</a><br /></td></tr>
<tr class="separator:ga1859e483fdc35d0102a16d01fec65b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a08619de9304c975c01d2315b286a5"><td class="memTemplParams" colspan="2">template&lt;typename order_iterator , typename value_iterator &gt; </td></tr>
<tr class="memitem:ga26a08619de9304c975c01d2315b286a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga26a08619de9304c975c01d2315b286a5">reorder_destructive</a> (const order_iterator order_begin, const order_iterator order_end, const value_iterator v)</td></tr>
<tr class="memdesc:ga26a08619de9304c975c01d2315b286a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders an array in place.  <a href="group__utils.html#ga26a08619de9304c975c01d2315b286a5">More...</a><br /></td></tr>
<tr class="separator:ga26a08619de9304c975c01d2315b286a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa895a2b168aa6e073ac2f487ec049d44"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa895a2b168aa6e073ac2f487ec049d44"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa895a2b168aa6e073ac2f487ec049d44">set_difference</a> (const std::set&lt; T &gt; &amp;s1, const std::set&lt; T &gt; &amp;s2)</td></tr>
<tr class="memdesc:gaa895a2b168aa6e073ac2f487ec049d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function wrapper around std::set_difference function.  <a href="group__utils.html#gaa895a2b168aa6e073ac2f487ec049d44">More...</a><br /></td></tr>
<tr class="separator:gaa895a2b168aa6e073ac2f487ec049d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf40b1696332f8c867ee9d14c89fff2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabaf40b1696332f8c867ee9d14c89fff2"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gabaf40b1696332f8c867ee9d14c89fff2">set_intersection</a> (const std::set&lt; T &gt; &amp;s1, const std::set&lt; T &gt; &amp;s2)</td></tr>
<tr class="memdesc:gabaf40b1696332f8c867ee9d14c89fff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function wrapper around std::set_intersection function.  <a href="group__utils.html#gabaf40b1696332f8c867ee9d14c89fff2">More...</a><br /></td></tr>
<tr class="separator:gabaf40b1696332f8c867ee9d14c89fff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e873692d2228c7fbcec4a0710bee17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga14e873692d2228c7fbcec4a0710bee17"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga14e873692d2228c7fbcec4a0710bee17">set_union</a> (const std::set&lt; T &gt; &amp;s1, const std::set&lt; T &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga14e873692d2228c7fbcec4a0710bee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function wrapper around std::set_union function.  <a href="group__utils.html#ga14e873692d2228c7fbcec4a0710bee17">More...</a><br /></td></tr>
<tr class="separator:ga14e873692d2228c7fbcec4a0710bee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536b304f6772b92747b14dfc29de891a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga536b304f6772b92747b14dfc29de891a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga536b304f6772b92747b14dfc29de891a">square</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ga536b304f6772b92747b14dfc29de891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">P.O.D.  <a href="group__utils.html#ga536b304f6772b92747b14dfc29de891a">More...</a><br /></td></tr>
<tr class="separator:ga536b304f6772b92747b14dfc29de891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c228b37187ea44153321837f43d4e51"><td class="memTemplParams" colspan="2">template&lt;auto &amp; S&gt; </td></tr>
<tr class="memitem:ga0c228b37187ea44153321837f43d4e51"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0c228b37187ea44153321837f43d4e51">symbol</a> ()</td></tr>
<tr class="memdesc:ga0c228b37187ea44153321837f43d4e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the template argument.  <a href="group__utils.html#ga0c228b37187ea44153321837f43d4e51">More...</a><br /></td></tr>
<tr class="separator:ga0c228b37187ea44153321837f43d4e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5af774450374ecdbbc2898bb65031e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e5af774450374ecdbbc2898bb65031e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga6e5af774450374ecdbbc2898bb65031e">type</a> ()</td></tr>
<tr class="memdesc:ga6e5af774450374ecdbbc2898bb65031e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the demangled name of the type T.  <a href="group__utils.html#ga6e5af774450374ecdbbc2898bb65031e">More...</a><br /></td></tr>
<tr class="separator:ga6e5af774450374ecdbbc2898bb65031e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14902e541853aef2482e355ba22bf1b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab14902e541853aef2482e355ba22bf1b">type</a> (const std::type_info &amp;type_info)</td></tr>
<tr class="memdesc:gab14902e541853aef2482e355ba22bf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the demangled name of the type identified by type_info.  <a href="group__utils.html#gab14902e541853aef2482e355ba22bf1b">More...</a><br /></td></tr>
<tr class="separator:gab14902e541853aef2482e355ba22bf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6718cd6b031b186bda77e535b7aa790"><td class="memTemplParams" colspan="2">template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:gab6718cd6b031b186bda77e535b7aa790"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gab6718cd6b031b186bda77e535b7aa790">unique_each</a> (std::map&lt; K, T &gt; &amp;m)</td></tr>
<tr class="memdesc:gab6718cd6b031b186bda77e535b7aa790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply force_unique to each element of a std::map.  <a href="group__utils.html#gab6718cd6b031b186bda77e535b7aa790">More...</a><br /></td></tr>
<tr class="separator:gab6718cd6b031b186bda77e535b7aa790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf2cd0a88fa7048fbc53b7d24ccda68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0bf2cd0a88fa7048fbc53b7d24ccda68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0bf2cd0a88fa7048fbc53b7d24ccda68">unique_each</a> (std::vector&lt; T &gt; &amp;vv)</td></tr>
<tr class="memdesc:ga0bf2cd0a88fa7048fbc53b7d24ccda68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply force_unique to each element of a std::vector.  <a href="group__utils.html#ga0bf2cd0a88fa7048fbc53b7d24ccda68">More...</a><br /></td></tr>
<tr class="separator:ga0bf2cd0a88fa7048fbc53b7d24ccda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Non-domain-specific infrastructure. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gab91f6cc1b8c725b6d4d29620999d336e" name="gab91f6cc1b8c725b6d4d29620999d336e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab91f6cc1b8c725b6d4d29620999d336e">&#9670;&nbsp;</a></span>FLECSI_TARGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLECSI_TARGET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a function available on a GPU. </p>
<p >Use before a return type or a lambda's parameter list. </p><dl class="section warning"><dt>Warning</dt><dd>Many implementations impose <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#language-restrictions">severe restrictions</a> on such functions. Most prominent is that they can call only other functions so annotated, preventing the use of much or all of many libraries (including the standard library). FleCSI documents certain classes and functions as being "supported for GPU execution". </dd></dl>

</div>
</div>
<a id="gadb0a7b5d1090ea55d936d3b15c66ca8d" name="gadb0a7b5d1090ea55d936d3b15c66ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb0a7b5d1090ea55d936d3b15c66ca8d">&#9670;&nbsp;</a></span>FLECSI_INLINE_TARGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLECSI_INLINE_TARGET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a function inline and available on a GPU. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__utils.html#gab91f6cc1b8c725b6d4d29620999d336e" title="Make a function available on a GPU.">FLECSI_TARGET</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0d633ccab8440bedc968dc221a91849f" name="ga0d633ccab8440bedc968dc221a91849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d633ccab8440bedc968dc221a91849f">&#9670;&nbsp;</a></span>Dimension</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> =  unsigned short</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for spatial dimensions and counts thereof. </p>

</div>
</div>
<a id="ga6dcbd6f3f473db13e944c75433a5ba8b" name="ga6dcbd6f3f473db13e944c75433a5ba8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcbd6f3f473db13e944c75433a5ba8b">&#9670;&nbsp;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">id</a> =  FLECSI_ID_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local (color-specific) topology entity ID type. </p>
<p >Often provided in a index-space-specific convertible wrapper. </p>

</div>
</div>
<a id="ga72254e85c5f54a8d398eac641258ee45" name="ga72254e85c5f54a8d398eac641258ee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72254e85c5f54a8d398eac641258ee45">&#9670;&nbsp;</a></span>gid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">gid</a> =  FLECSI_GID_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global topology entity ID type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga43129c21901de6eff552977dbbd5cb42" name="ga43129c21901de6eff552977dbbd5cb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43129c21901de6eff552977dbbd5cb42">&#9670;&nbsp;</a></span>bit_width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T flecsi::util::bit_width </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple emulation of std::bit_width from C++20. </p>

</div>
</div>
<a id="ga536b304f6772b92747b14dfc29de891a" name="ga536b304f6772b92747b14dfc29de891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga536b304f6772b92747b14dfc29de891a">&#9670;&nbsp;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T flecsi::util::square </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>P.O.D. </p>

</div>
</div>
<a id="ga090b1ad4ee999a66e624adfb9adc65be" name="ga090b1ad4ee999a66e624adfb9adc65be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga090b1ad4ee999a66e624adfb9adc65be">&#9670;&nbsp;</a></span>force_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flecsi::util::force_unique </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a std::vector and remove duplicates. </p>

</div>
</div>
<a id="gab6718cd6b031b186bda77e535b7aa790" name="gab6718cd6b031b186bda77e535b7aa790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6718cd6b031b186bda77e535b7aa790">&#9670;&nbsp;</a></span>unique_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flecsi::util::unique_each </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; K, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply force_unique to each element of a std::map. </p>
<p >Note that force_unique is currently only implemented for std::vector. </p>

</div>
</div>
<a id="ga0bf2cd0a88fa7048fbc53b7d24ccda68" name="ga0bf2cd0a88fa7048fbc53b7d24ccda68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf2cd0a88fa7048fbc53b7d24ccda68">&#9670;&nbsp;</a></span>unique_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flecsi::util::unique_each </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply force_unique to each element of a std::vector. </p>
<p >Note that force_unique is currently only implemented for std::vector. </p>

</div>
</div>
<a id="gab38729997ae0745c4d90e7e2cafb32fa" name="gab38729997ae0745c4d90e7e2cafb32fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38729997ae0745c4d90e7e2cafb32fa">&#9670;&nbsp;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string demangle </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the demangled name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The string to demangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e5af774450374ecdbbc2898bb65031e" name="ga6e5af774450374ecdbbc2898bb65031e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e5af774450374ecdbbc2898bb65031e">&#9670;&nbsp;</a></span>type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string flecsi::util::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the demangled name of the type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type (references and cv-qualification ignored) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab14902e541853aef2482e355ba22bf1b" name="gab14902e541853aef2482e355ba22bf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab14902e541853aef2482e355ba22bf1b">&#9670;&nbsp;</a></span>type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string flecsi::util::type </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the demangled name of the type identified by type_info. </p>

</div>
</div>
<a id="ga0c228b37187ea44153321837f43d4e51" name="ga0c228b37187ea44153321837f43d4e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c228b37187ea44153321837f43d4e51">&#9670;&nbsp;</a></span>symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string flecsi::util::symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the template argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">a</td><td>reference to a function or variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>demangled name </dd></dl>

</div>
</div>
<a id="ga171881d08c3db40bdaa058ee1dd37c4d" name="ga171881d08c3db40bdaa058ee1dd37c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga171881d08c3db40bdaa058ee1dd37c4d">&#9670;&nbsp;</a></span>color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Color &gt; flecsi::util::parmetis::color </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1offsets.html">util::offsets</a> &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1crs.html">crs</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_t&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a coloring of the given naive graph partition into <em>colors</em> colors. </p>
<p >This function uses <code>ParMETIS_V3_PartKway</code>. Each process in the comm must participate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>distribution of entities over ranks </td></tr>
    <tr><td class="paramname">graph</td><td>local connectivity graph </td></tr>
    <tr><td class="paramname">colors</td><td>The number of partitions to create. </td></tr>
    <tr><td class="paramname">comm</td><td>An MPI_Comm object that defines the number of processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1859e483fdc35d0102a16d01fec65b28" name="ga1859e483fdc35d0102a16d01fec65b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1859e483fdc35d0102a16d01fec65b28">&#9670;&nbsp;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flecsi::util::reorder </td>
          <td>(</td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_iterator&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders an array in place. </p>
<dl class="section remark"><dt>Remarks</dt><dd>this version maintains the order array </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order_begin</td><td>The begin iterator for the order array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order_end</td><td>The end iterator for the order array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>The begin iterator for the value array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26a08619de9304c975c01d2315b286a5" name="ga26a08619de9304c975c01d2315b286a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26a08619de9304c975c01d2315b286a5">&#9670;&nbsp;</a></span>reorder_destructive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flecsi::util::reorder_destructive </td>
          <td>(</td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_iterator&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders an array in place. </p>
<dl class="section remark"><dt>Remarks</dt><dd>this version destroys the order array for performance gains </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">order_begin</td><td>The begin iterator for the order array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">order_end</td><td>The end iterator for the order array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>The begin iterator for the value array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95c20a85c5e76f886f6535b6ab3a7eb4" name="ga95c20a85c5e76f886f6535b6ab3a7eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c20a85c5e76f886f6535b6ab3a7eb4">&#9670;&nbsp;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flecsi::util::intersects </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect intersections of sorted lists. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function has complexity O(n + m) </dd></dl>

</div>
</div>
<a id="gabaf40b1696332f8c867ee9d14c89fff2" name="gabaf40b1696332f8c867ee9d14c89fff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf40b1696332f8c867ee9d14c89fff2">&#9670;&nbsp;</a></span>set_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; flecsi::util::set_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function wrapper around std::set_intersection function. </p>
<p >This version computes the intersection of two sets and returns the result as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first set of the intersection. </td></tr>
    <tr><td class="paramname">s2</td><td>The second set of the intersection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing the intersection of s1 with s2. </dd></dl>

</div>
</div>
<a id="ga14e873692d2228c7fbcec4a0710bee17" name="ga14e873692d2228c7fbcec4a0710bee17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14e873692d2228c7fbcec4a0710bee17">&#9670;&nbsp;</a></span>set_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; flecsi::util::set_union </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function wrapper around std::set_union function. </p>
<p >This version computes the union of two sets and returns the result as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first set of the union. </td></tr>
    <tr><td class="paramname">s2</td><td>The second set of the union.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing the union of s1 with s2. </dd></dl>

</div>
</div>
<a id="gaa895a2b168aa6e073ac2f487ec049d44" name="gaa895a2b168aa6e073ac2f487ec049d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa895a2b168aa6e073ac2f487ec049d44">&#9670;&nbsp;</a></span>set_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; flecsi::util::set_difference </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function wrapper around std::set_difference function. </p>
<p >This version computes the difference of two sets and returns the result as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first set of the difference. </td></tr>
    <tr><td class="paramname">s2</td><td>The second set of the difference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing the difference of s1 with s2. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
