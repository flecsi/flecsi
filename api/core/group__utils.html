<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FleCSI Core API: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="flecsi.png"/></td>
  <td id="projectalign">
   <div id="projectname">FleCSI Core API<span id="projectnumber">&#160;Version: 2.3.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__utils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utilities</div></div>
</div><!--header-->
<div class="contents">

<p>Non-domain-specific infrastructure.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__annotation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__annotation.html">Profiling</a></td></tr>
<tr class="memdesc:group__annotation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Markers for categorizing performance measurements. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__fillingcurves"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fillingcurves.html">Filling Curves</a></td></tr>
<tr class="memdesc:group__fillingcurves"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space-filling curve, key generators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__kdtree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kdtree.html">KDTree</a></td></tr>
<tr class="memdesc:group__kdtree"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structflecsi_1_1util_1_1KDTree.html" title="A k-d tree for efficiently finding intersections between shapes.">KDTree</a> based search utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html">Point</a></td></tr>
<tr class="memdesc:group__point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial representation of a point based on <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__graphviz"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__graphviz.html">Graphviz Support</a></td></tr>
<tr class="memdesc:group__graphviz"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code>libcgraph</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mpi-utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpi-utils.html">MPI</a></td></tr>
<tr class="memdesc:group__mpi-utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">These require MPI tasks, not the MPI backend. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__serial"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html">Serialization</a></td></tr>
<tr class="memdesc:group__serial"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization without default constructibility. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__unit"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unit.html">Unit Testing</a></td></tr>
<tr class="memdesc:group__unit"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit test framework much like Google Test but with task support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ranges.html">Ranges</a></td></tr>
<tr class="memdesc:group__ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range and iterator tools, mostly backported from the standard library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1counter.html">counter&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter with a maximum.  <a href="structflecsi_1_1util_1_1counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1crs.html">crs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient (compressed-row) storage for a sequence of sequences of integers.  <a href="structflecsi_1_1util_1_1crs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1dag.html">dag&lt; NodePolicy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic DAG type.  <a href="structflecsi_1_1util_1_1dag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array&lt; TYPE, DIMENSION, NAMESPACE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a> type provides a general base for defining contiguous array types that have a specific dimension.  <a href="classflecsi_1_1util_1_1dimensioned__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1equal__map.html">equal_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition with substrings of equal size.  <a href="structflecsi_1_1util_1_1equal__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a type as itself in functional contexts.  <a href="structflecsi_1_1util_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1key__tuple.html">key_tuple&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::tuple containing the given types and indexed by the given keys.  <a href="structflecsi_1_1util_1_1key__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1map__base.html">map_base&lt; D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition of some prefix of the whole numbers into substrings.  <a href="structflecsi_1_1util_1_1map__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1move__optional.html">move_optional&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty upon move.  <a href="structflecsi_1_1util_1_1move__optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1offsets.html">offsets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition with substrings of arbitrary size.  <a href="structflecsi_1_1util_1_1offsets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1sort.html">sort&lt; FieldRef &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort object implementing a distributed sort and load balancing.  <a href="structflecsi_1_1util_1_1sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflecsi_1_1util_1_1Symbol.html">Symbol&lt; S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy class template.  <a href="structflecsi_1_1util_1_1Symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6d4fa2c2d5972c15d3c7114871987f16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga6d4fa2c2d5972c15d3c7114871987f16">FLECSI_DEVICE_CODE</a></td></tr>
<tr class="memdesc:ga6d4fa2c2d5972c15d3c7114871987f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify if the code is being built on GPU.  <br /></td></tr>
<tr class="separator:ga6d4fa2c2d5972c15d3c7114871987f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb0a7b5d1090ea55d936d3b15c66ca8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadb0a7b5d1090ea55d936d3b15c66ca8d">FLECSI_INLINE_TARGET</a></td></tr>
<tr class="memdesc:gadb0a7b5d1090ea55d936d3b15c66ca8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a function inline and available on a GPU.  <br /></td></tr>
<tr class="separator:gadb0a7b5d1090ea55d936d3b15c66ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91f6cc1b8c725b6d4d29620999d336e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab91f6cc1b8c725b6d4d29620999d336e">FLECSI_TARGET</a></td></tr>
<tr class="memdesc:gab91f6cc1b8c725b6d4d29620999d336e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a function available on a GPU.  <br /></td></tr>
<tr class="separator:gab91f6cc1b8c725b6d4d29620999d336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0d633ccab8440bedc968dc221a91849f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> = unsigned short</td></tr>
<tr class="memdesc:ga0d633ccab8440bedc968dc221a91849f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for spatial dimensions and counts thereof.  <br /></td></tr>
<tr class="separator:ga0d633ccab8440bedc968dc221a91849f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72254e85c5f54a8d398eac641258ee45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">gid</a> = FLECSI_GID_TYPE</td></tr>
<tr class="memdesc:ga72254e85c5f54a8d398eac641258ee45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global topology entity ID type.  <br /></td></tr>
<tr class="separator:ga72254e85c5f54a8d398eac641258ee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcbd6f3f473db13e944c75433a5ba8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">id</a> = FLECSI_ID_TYPE</td></tr>
<tr class="memdesc:ga6dcbd6f3f473db13e944c75433a5ba8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local (color-specific) topology entity ID type.  <br /></td></tr>
<tr class="separator:ga6dcbd6f3f473db13e944c75433a5ba8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf8cbcb05fe17534adaaf473f98dc57fb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf8cbcb05fe17534adaaf473f98dc57fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gaf8cbcb05fe17534adaaf473f98dc57fb">bit_width</a> (T x) noexcept</td></tr>
<tr class="memdesc:gaf8cbcb05fe17534adaaf473f98dc57fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple emulation of std::bit_width from C++20.  <br /></td></tr>
<tr class="separator:gaf8cbcb05fe17534adaaf473f98dc57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3143790d16e2075e12b625290311e67d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Color &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga3143790d16e2075e12b625290311e67d">color</a> (const <a class="el" href="structflecsi_1_1util_1_1offsets.html">util::offsets</a> &amp;dist, const <a class="el" href="structflecsi_1_1util_1_1crs.html">crs</a> &amp;graph, idx_t <a class="el" href="group__runtime.html#ga8201a75d28d35d62aa168890e291df65">colors</a>, MPI_Comm comm=MPI_COMM_WORLD)</td></tr>
<tr class="memdesc:ga3143790d16e2075e12b625290311e67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a coloring of the given naive graph partition into <em>colors</em> colors.  <br /></td></tr>
<tr class="separator:ga3143790d16e2075e12b625290311e67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38729997ae0745c4d90e7e2cafb32fa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab38729997ae0745c4d90e7e2cafb32fa">demangle</a> (const char *const name)</td></tr>
<tr class="memdesc:gab38729997ae0745c4d90e7e2cafb32fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the demangled name.  <br /></td></tr>
<tr class="separator:gab38729997ae0745c4d90e7e2cafb32fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5be32e8cc1e83af2ff4000a54f16f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9a5be32e8cc1e83af2ff4000a54f16f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9a5be32e8cc1e83af2ff4000a54f16f5">force_unique</a> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga9a5be32e8cc1e83af2ff4000a54f16f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a std::vector and remove duplicates.  <br /></td></tr>
<tr class="separator:ga9a5be32e8cc1e83af2ff4000a54f16f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ad82ea19e88b79aaa9b3475aa726f4"><td class="memTemplParams" colspan="2">template&lt;class InputIt1 , class InputIt2 &gt; </td></tr>
<tr class="memitem:gaa4ad82ea19e88b79aaa9b3475aa726f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa4ad82ea19e88b79aaa9b3475aa726f4">intersects</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2)</td></tr>
<tr class="memdesc:gaa4ad82ea19e88b79aaa9b3475aa726f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect intersections of sorted lists.  <br /></td></tr>
<tr class="separator:gaa4ad82ea19e88b79aaa9b3475aa726f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b0a989d5408b53b44a66c723c67741"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> DIMENSION, std::size_t NAMESPACE&gt; </td></tr>
<tr class="memitem:ga83b0a989d5408b53b44a66c723c67741"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga83b0a989d5408b53b44a66c723c67741">operator+</a> (const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;lhs, const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga83b0a989d5408b53b44a66c723c67741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator.  <br /></td></tr>
<tr class="separator:ga83b0a989d5408b53b44a66c723c67741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31623982ffa086af59566b9c7208cf3"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> DIMENSION, std::size_t NAMESPACE&gt; </td></tr>
<tr class="memitem:gad31623982ffa086af59566b9c7208cf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gad31623982ffa086af59566b9c7208cf3">operator-</a> (const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;lhs, const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad31623982ffa086af59566b9c7208cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator.  <br /></td></tr>
<tr class="separator:gad31623982ffa086af59566b9c7208cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7878ee4092ec9f8006c686ced4426d6"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> DIMENSION, std::size_t NAMESPACE&gt; </td></tr>
<tr class="memitem:gac7878ee4092ec9f8006c686ced4426d6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gac7878ee4092ec9f8006c686ced4426d6">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; const &amp;a)</td></tr>
<tr class="memdesc:gac7878ee4092ec9f8006c686ced4426d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator.  <br /></td></tr>
<tr class="separator:gac7878ee4092ec9f8006c686ced4426d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2dbba6504f66bd8814581374a95e02"><td class="memTemplParams" colspan="2">template&lt;typename order_iterator , typename value_iterator &gt; </td></tr>
<tr class="memitem:gacc2dbba6504f66bd8814581374a95e02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gacc2dbba6504f66bd8814581374a95e02">reorder</a> (const order_iterator order_begin, const order_iterator order_end, const value_iterator v)</td></tr>
<tr class="memdesc:gacc2dbba6504f66bd8814581374a95e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders an array in place.  <br /></td></tr>
<tr class="separator:gacc2dbba6504f66bd8814581374a95e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99224fc017b020065039157f96a74faa"><td class="memTemplParams" colspan="2">template&lt;typename order_iterator , typename value_iterator &gt; </td></tr>
<tr class="memitem:ga99224fc017b020065039157f96a74faa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga99224fc017b020065039157f96a74faa">reorder_destructive</a> (const order_iterator order_begin, const order_iterator order_end, const value_iterator v)</td></tr>
<tr class="memdesc:ga99224fc017b020065039157f96a74faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders an array in place.  <br /></td></tr>
<tr class="separator:ga99224fc017b020065039157f96a74faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2eaf23ac7513e3d7c85c931221a9f2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa2eaf23ac7513e3d7c85c931221a9f2f"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa2eaf23ac7513e3d7c85c931221a9f2f">set_difference</a> (const std::set&lt; T &gt; &amp;s1, const std::set&lt; T &gt; &amp;s2)</td></tr>
<tr class="memdesc:gaa2eaf23ac7513e3d7c85c931221a9f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function wrapper around std::set_difference function.  <br /></td></tr>
<tr class="separator:gaa2eaf23ac7513e3d7c85c931221a9f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2e00fa178362a81350b8db4f95d68b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaac2e00fa178362a81350b8db4f95d68b"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gaac2e00fa178362a81350b8db4f95d68b">set_intersection</a> (const std::set&lt; T &gt; &amp;s1, const std::set&lt; T &gt; &amp;s2)</td></tr>
<tr class="memdesc:gaac2e00fa178362a81350b8db4f95d68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function wrapper around std::set_intersection function.  <br /></td></tr>
<tr class="separator:gaac2e00fa178362a81350b8db4f95d68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79413767c2d651fca84ba7364c6ed621"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga79413767c2d651fca84ba7364c6ed621"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga79413767c2d651fca84ba7364c6ed621">set_union</a> (const std::set&lt; T &gt; &amp;s1, const std::set&lt; T &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga79413767c2d651fca84ba7364c6ed621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function wrapper around std::set_union function.  <br /></td></tr>
<tr class="separator:ga79413767c2d651fca84ba7364c6ed621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9a02ada9ac676424c06a741feb8d98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacd9a02ada9ac676424c06a741feb8d98"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gacd9a02ada9ac676424c06a741feb8d98">square</a> (const T &amp;a)</td></tr>
<tr class="memdesc:gacd9a02ada9ac676424c06a741feb8d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">P.O.D.  <br /></td></tr>
<tr class="separator:gacd9a02ada9ac676424c06a741feb8d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32db8bd73ac6166a44338260dd3c433e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga32db8bd73ac6166a44338260dd3c433e">strip_parameter_list</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ga32db8bd73ac6166a44338260dd3c433e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return signature without parameter list.  <br /></td></tr>
<tr class="separator:ga32db8bd73ac6166a44338260dd3c433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7c325941b43a7e95f3fed6064e2816"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaea7c325941b43a7e95f3fed6064e2816">strip_return_type</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:gaea7c325941b43a7e95f3fed6064e2816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return signature without return type.  <br /></td></tr>
<tr class="separator:gaea7c325941b43a7e95f3fed6064e2816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9edd03a1f1bb741f349a7ae7c77615d2"><td class="memTemplParams" colspan="2">template&lt;auto &amp; S&gt; </td></tr>
<tr class="memitem:ga9edd03a1f1bb741f349a7ae7c77615d2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9edd03a1f1bb741f349a7ae7c77615d2">symbol</a> ()</td></tr>
<tr class="memdesc:ga9edd03a1f1bb741f349a7ae7c77615d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the template argument.  <br /></td></tr>
<tr class="separator:ga9edd03a1f1bb741f349a7ae7c77615d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7075477aed7a29852ef299b5b5231a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gafd7075477aed7a29852ef299b5b5231a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gafd7075477aed7a29852ef299b5b5231a">type</a> ()</td></tr>
<tr class="memdesc:gafd7075477aed7a29852ef299b5b5231a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the demangled name of the type T.  <br /></td></tr>
<tr class="separator:gafd7075477aed7a29852ef299b5b5231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3edd83421e592b32d56e73675843f09b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga3edd83421e592b32d56e73675843f09b">type</a> (const std::type_info &amp;type_info)</td></tr>
<tr class="memdesc:ga3edd83421e592b32d56e73675843f09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the demangled name of the type identified by type_info.  <br /></td></tr>
<tr class="separator:ga3edd83421e592b32d56e73675843f09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d8b8e374eeb048955c86d17b7616b7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename T &gt; </td></tr>
<tr class="memitem:ga07d8b8e374eeb048955c86d17b7616b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#ga07d8b8e374eeb048955c86d17b7616b7">unique_each</a> (std::map&lt; K, T &gt; &amp;m)</td></tr>
<tr class="memdesc:ga07d8b8e374eeb048955c86d17b7616b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply force_unique to each element of a std::map.  <br /></td></tr>
<tr class="separator:ga07d8b8e374eeb048955c86d17b7616b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8edf62ee554804b78813b553dac342"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaea8edf62ee554804b78813b553dac342"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utils.html#gaea8edf62ee554804b78813b553dac342">unique_each</a> (std::vector&lt; T &gt; &amp;vv)</td></tr>
<tr class="memdesc:gaea8edf62ee554804b78813b553dac342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply force_unique to each element of a std::vector.  <br /></td></tr>
<tr class="separator:gaea8edf62ee554804b78813b553dac342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Non-domain-specific infrastructure. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;flecsi/utilities.hh&quot;</span></div>
</div><!-- fragment --><p>This header provides the features in the following additional <b>deprecated</b> headers:</p><ul>
<li><a class="el" href="group__annotation.html">flecsi/util/annotation.hh</a></li>
<li><a class="el" href="group__ranges.html">flecsi/util/array_ref.hh</a></li>
<li>flecsi/util/color_map.hh</li>
<li>flecsi/util/common.hh</li>
<li>flecsi/util/dag.hh</li>
<li>flecsi/util/demangle.hh</li>
<li><a class="el" href="group__point.html">flecsi/util/dimensioned_array.hh</a></li>
<li><a class="el" href="group__mpi-utils.html">flecsi/util/mpi.hh</a></li>
<li>flecsi/util/reorder.hh</li>
<li><a class="el" href="group__serial.html">flecsi/util/serialize.hh</a></li>
<li>flecsi/util/set_intersection.hh</li>
<li>flecsi/util/set_utils.hh</li>
<li><a class="el" href="group__unit.html">flecsi/util/unit.hh</a> </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gab91f6cc1b8c725b6d4d29620999d336e" name="gab91f6cc1b8c725b6d4d29620999d336e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab91f6cc1b8c725b6d4d29620999d336e">&#9670;&#160;</a></span>FLECSI_TARGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLECSI_TARGET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a function available on a GPU. </p>
<p>Use before a return type or a lambda's parameter list. </p><dl class="section warning"><dt>Warning</dt><dd>Many implementations impose <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#language-restrictions">severe restrictions</a> on such functions. Most prominent is that they can call only other functions so annotated, preventing the use of much or all of many libraries (including the standard library). FleCSI documents certain classes and functions as being "supported for GPU execution". </dd></dl>

</div>
</div>
<a id="gadb0a7b5d1090ea55d936d3b15c66ca8d" name="gadb0a7b5d1090ea55d936d3b15c66ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb0a7b5d1090ea55d936d3b15c66ca8d">&#9670;&#160;</a></span>FLECSI_INLINE_TARGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLECSI_INLINE_TARGET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a function inline and available on a GPU. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__utils.html#gab91f6cc1b8c725b6d4d29620999d336e" title="Make a function available on a GPU.">FLECSI_TARGET</a> </dd></dl>

</div>
</div>
<a id="ga6d4fa2c2d5972c15d3c7114871987f16" name="ga6d4fa2c2d5972c15d3c7114871987f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4fa2c2d5972c15d3c7114871987f16">&#9670;&#160;</a></span>FLECSI_DEVICE_CODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLECSI_DEVICE_CODE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify if the code is being built on GPU. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0d633ccab8440bedc968dc221a91849f" name="ga0d633ccab8440bedc968dc221a91849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d633ccab8440bedc968dc221a91849f">&#9670;&#160;</a></span>Dimension</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> =  unsigned short</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for spatial dimensions and counts thereof. </p>

</div>
</div>
<a id="ga6dcbd6f3f473db13e944c75433a5ba8b" name="ga6dcbd6f3f473db13e944c75433a5ba8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcbd6f3f473db13e944c75433a5ba8b">&#9670;&#160;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utils.html#ga6dcbd6f3f473db13e944c75433a5ba8b">id</a> =  FLECSI_ID_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local (color-specific) topology entity ID type. </p>
<p>Often provided in a index-space-specific convertible wrapper. </p>

</div>
</div>
<a id="ga72254e85c5f54a8d398eac641258ee45" name="ga72254e85c5f54a8d398eac641258ee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72254e85c5f54a8d398eac641258ee45">&#9670;&#160;</a></span>gid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utils.html#ga72254e85c5f54a8d398eac641258ee45">gid</a> =  FLECSI_GID_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global topology entity ID type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf8cbcb05fe17534adaaf473f98dc57fb" name="gaf8cbcb05fe17534adaaf473f98dc57fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8cbcb05fe17534adaaf473f98dc57fb">&#9670;&#160;</a></span>bit_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T bit_width </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple emulation of std::bit_width from C++20. </p>

</div>
</div>
<a id="gacd9a02ada9ac676424c06a741feb8d98" name="gacd9a02ada9ac676424c06a741feb8d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd9a02ada9ac676424c06a741feb8d98">&#9670;&#160;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T square </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>P.O.D. </p>

</div>
</div>
<a id="ga9a5be32e8cc1e83af2ff4000a54f16f5" name="ga9a5be32e8cc1e83af2ff4000a54f16f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a5be32e8cc1e83af2ff4000a54f16f5">&#9670;&#160;</a></span>force_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void force_unique </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a std::vector and remove duplicates. </p>

</div>
</div>
<a id="ga07d8b8e374eeb048955c86d17b7616b7" name="ga07d8b8e374eeb048955c86d17b7616b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d8b8e374eeb048955c86d17b7616b7">&#9670;&#160;</a></span>unique_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unique_each </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; K, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply force_unique to each element of a std::map. </p>
<p>Note that force_unique is currently only implemented for std::vector. </p>

</div>
</div>
<a id="gaea8edf62ee554804b78813b553dac342" name="gaea8edf62ee554804b78813b553dac342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8edf62ee554804b78813b553dac342">&#9670;&#160;</a></span>unique_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unique_each </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply force_unique to each element of a std::vector. </p>
<p>Note that force_unique is currently only implemented for std::vector. </p>

</div>
</div>
<a id="gab38729997ae0745c4d90e7e2cafb32fa" name="gab38729997ae0745c4d90e7e2cafb32fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38729997ae0745c4d90e7e2cafb32fa">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string demangle </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the demangled name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The string to demangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32db8bd73ac6166a44338260dd3c433e" name="ga32db8bd73ac6166a44338260dd3c433e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32db8bd73ac6166a44338260dd3c433e">&#9670;&#160;</a></span>strip_parameter_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string strip_parameter_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return signature without parameter list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>The function signature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea7c325941b43a7e95f3fed6064e2816" name="gaea7c325941b43a7e95f3fed6064e2816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea7c325941b43a7e95f3fed6064e2816">&#9670;&#160;</a></span>strip_return_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string strip_return_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return signature without return type. </p>
<p>While this works for many cases, if the heuristic fails to detect the return type, it will return the full signature.</p>
<p>Example of a not supported signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f&lt;X&lt;void, K&lt;(0)&gt; e&lt;0, 0&gt;()&gt;()</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>The function signature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd7075477aed7a29852ef299b5b5231a" name="gafd7075477aed7a29852ef299b5b5231a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd7075477aed7a29852ef299b5b5231a">&#9670;&#160;</a></span>type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the demangled name of the type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type (references and cv-qualification ignored) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3edd83421e592b32d56e73675843f09b" name="ga3edd83421e592b32d56e73675843f09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3edd83421e592b32d56e73675843f09b">&#9670;&#160;</a></span>type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string type </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the demangled name of the type identified by type_info. </p>

</div>
</div>
<a id="ga9edd03a1f1bb741f349a7ae7c77615d2" name="ga9edd03a1f1bb741f349a7ae7c77615d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9edd03a1f1bb741f349a7ae7c77615d2">&#9670;&#160;</a></span>symbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp; S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the template argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">a</td><td>reference to a function or variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>demangled name </dd></dl>

</div>
</div>
<a id="ga83b0a989d5408b53b44a66c723c67741" name="ga83b0a989d5408b53b44a66c723c67741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b0a989d5408b53b44a66c723c67741">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> DIMENSION, std::size_t NAMESPACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the array, e.g., P.O.D. type. </td></tr>
    <tr><td class="paramname">DIMENSION</td><td>The dimension of the array, i.e., the number of elements to be stored in the array. </td></tr>
    <tr><td class="paramname">NAMESPACE</td><td>The namespace of the array. This is a dummy parameter that is useful for creating distinct types that alias <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad31623982ffa086af59566b9c7208cf3" name="gad31623982ffa086af59566b9c7208cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31623982ffa086af59566b9c7208cf3">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> DIMENSION, std::size_t NAMESPACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the array, e.g., P.O.D. type. </td></tr>
    <tr><td class="paramname">DIMENSION</td><td>The dimension of the array, i.e., the number of elements to be stored in the array. </td></tr>
    <tr><td class="paramname">NAMESPACE</td><td>The namespace of the array. This is a dummy parameter that is useful for creating distinct types that alias <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac7878ee4092ec9f8006c686ced4426d6" name="gac7878ee4092ec9f8006c686ced4426d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7878ee4092ec9f8006c686ced4426d6">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , <a class="el" href="group__utils.html#ga0d633ccab8440bedc968dc221a91849f">Dimension</a> DIMENSION, std::size_t NAMESPACE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html">dimensioned_array</a>&lt; TYPE, DIMENSION, NAMESPACE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the array, e.g., P.O.D. type. </td></tr>
    <tr><td class="paramname">DIMENSION</td><td>The dimension of the array, i.e., the number of elements to be stored in the array. </td></tr>
    <tr><td class="paramname">NAMESPACE</td><td>The namespace of the array. This is a dummy parameter that is useful for creating distinct types that alias <a class="el" href="classflecsi_1_1util_1_1dimensioned__array.html" title="The dimensioned_array type provides a general base for defining contiguous array types that have a sp...">dimensioned_array</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output stream. </td></tr>
    <tr><td class="paramname">a</td><td>The dimensioned array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3143790d16e2075e12b625290311e67d" name="ga3143790d16e2075e12b625290311e67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3143790d16e2075e12b625290311e67d">&#9670;&#160;</a></span>color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Color &gt; color </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1offsets.html">util::offsets</a> &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflecsi_1_1util_1_1crs.html">crs</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_t&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a coloring of the given naive graph partition into <em>colors</em> colors. </p>
<p>This function uses <code>ParMETIS_V3_PartKway</code>. Each process in the comm must participate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>distribution of entities over ranks </td></tr>
    <tr><td class="paramname">graph</td><td>local connectivity graph </td></tr>
    <tr><td class="paramname">colors</td><td>The number of partitions to create. </td></tr>
    <tr><td class="paramname">comm</td><td>An MPI_Comm object that defines the number of processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc2dbba6504f66bd8814581374a95e02" name="gacc2dbba6504f66bd8814581374a95e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc2dbba6504f66bd8814581374a95e02">&#9670;&#160;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename order_iterator , typename value_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reorder </td>
          <td>(</td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_iterator&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders an array in place. </p>
<dl class="section remark"><dt>Remarks</dt><dd>this version maintains the order array </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order_begin</td><td>The begin iterator for the order array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order_end</td><td>The end iterator for the order array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>The begin iterator for the value array </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Unused. </dd></dl>

</div>
</div>
<a id="ga99224fc017b020065039157f96a74faa" name="ga99224fc017b020065039157f96a74faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99224fc017b020065039157f96a74faa">&#9670;&#160;</a></span>reorder_destructive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename order_iterator , typename value_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reorder_destructive </td>
          <td>(</td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const order_iterator&#160;</td>
          <td class="paramname"><em>order_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_iterator&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders an array in place. </p>
<dl class="section remark"><dt>Remarks</dt><dd>this version destroys the order array for performance gains </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">order_begin</td><td>The begin iterator for the order array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">order_end</td><td>The end iterator for the order array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>The begin iterator for the value array </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Unused. </dd></dl>

</div>
</div>
<a id="gaa4ad82ea19e88b79aaa9b3475aa726f4" name="gaa4ad82ea19e88b79aaa9b3475aa726f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4ad82ea19e88b79aaa9b3475aa726f4">&#9670;&#160;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt1 , class InputIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool intersects </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect intersections of sorted lists. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function has complexity O(n + m) </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Unused. </dd></dl>

</div>
</div>
<a id="gaac2e00fa178362a81350b8db4f95d68b" name="gaac2e00fa178362a81350b8db4f95d68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac2e00fa178362a81350b8db4f95d68b">&#9670;&#160;</a></span>set_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; set_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function wrapper around std::set_intersection function. </p>
<p>This version computes the intersection of two sets and returns the result as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first set of the intersection. </td></tr>
    <tr><td class="paramname">s2</td><td>The second set of the intersection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing the intersection of s1 with s2. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Unused. </dd></dl>

</div>
</div>
<a id="ga79413767c2d651fca84ba7364c6ed621" name="ga79413767c2d651fca84ba7364c6ed621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79413767c2d651fca84ba7364c6ed621">&#9670;&#160;</a></span>set_union()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; set_union </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function wrapper around std::set_union function. </p>
<p>This version computes the union of two sets and returns the result as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first set of the union. </td></tr>
    <tr><td class="paramname">s2</td><td>The second set of the union.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing the union of s1 with s2. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Unused. </dd></dl>

</div>
</div>
<a id="gaa2eaf23ac7513e3d7c85c931221a9f2f" name="gaa2eaf23ac7513e3d7c85c931221a9f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2eaf23ac7513e3d7c85c931221a9f2f">&#9670;&#160;</a></span>set_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; T &gt; set_difference </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function wrapper around std::set_difference function. </p>
<p>This version computes the difference of two sets and returns the result as a set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first set of the difference. </td></tr>
    <tr><td class="paramname">s2</td><td>The second set of the difference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing the difference of s1 with s2. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Unused. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
